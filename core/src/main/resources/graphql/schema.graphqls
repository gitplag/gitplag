scalar LocalDateTime

# Analysis result
type Analysis {
    # Analysis id
    id: ID!,

    # Date of the execution of the analysis
    executionDate: LocalDateTime!,

    # Used analyser
    analyser: String!,

    # Used language
    language: String!,

    # Pairs of compared users
    analysisPairs: [AnalysisPair]!
}

# Pair of two analysed and compared solutions
type AnalysisPair {

    # AnalysisPair id
    id: ID!

    # Name of first student
    student1: String!

    # Name of second student
    student2: String!

    # Count of matched lines
    lines: Int!

    # Percentage of similarity
    percentage: Int!

    # Pairs of matched lines
    analysisPairLines: [AnalysisPairLines]!
}

# Pairs of matched lines
type AnalysisPairLines {

    # AnalysisPairLines id
    id: ID!

    # Line "from" of the student1
    from1: Int!

    # Line "to" of the student1
    to1: Int!

    # Line "from" of the student2
    from2: Int!

    # Line "to" of the student2
    to2: Int!
}

# Repo
type Repository {

    # Repo id
    id: ID!,

    # Name of the repo
    name: String!,

    # Git service of the repository
    gitService: String!,

    # The main language of the repository
    language: String,

    # Regexps for managed files
    filePatterns: [String],

    # Default analyser
    analyser: String,

    # Does the periodic analysis enabled
    periodicAnalysis: Boolean,

    # Delay of the periodic analysis in minutes
    periodicAnalysisDelay: Int,

    # Names of managed branches
    branches: [String],

    # Processing grade of analysis results
    analysisMode: String
}

type BaseFileRecord {
    id: ID!,

    fileName: String!,

    branch: String!,

    repo: Repository!
}

type SolutionFileRecord {
    id: ID!,

    pullRequest: PullRequest!,

    fileName: String!,

    countOfLines: Int!
}

type ComposedFiles {
    bases: [BaseFileRecord]!,
    solutions: [SolutionFileRecord]!
}

type PullRequest {
    id: ID!,
    repo: Repository!,
    number: Int!,
    creatorName: String!,
    sourceRepoId: Long!,
    mainRepoId: Long!,
    sourceRepoFullName: String!,
    headSha: String!,
    sourceBranchName: String!,
    mainBranchName: String!,
    createdAt: LocalDateTime!,
    updatedAt: LocalDateTime!
}

type Query {

    # Get a result of the analysis of two solutions
    analysis(

    # Git service of the repository
    gitService: String!,

    # Name of the repository
    repo: String!):Analysis!

    # Run analysis for a repository
    analyse(

    # Git service of the repository (github, gitlab or bitbucket)
    gitService: String!,

    # Name of the repository
    repo: String!,

    # Branch to analyse
    branch: String!,

    # Chosen plagiarism analyser (moss or jplag)
    analyser: String,

    # Mode of the analysis (link, pairs or full)
    mode: String,

    # Chosen programming language
    language: String):Analysis!

    # Run analysis of the repo with detached response
    analyseDetached(

    # Git service of the repository (github, gitlab or bitbucket)
    gitService: String!,

    # Name of the repository
    repo: String!,

    # Branch to analyse
    branch: String!,

    # Response url
    responseUrl: String!,

    # Chosen plagiarism analyser (moss or jplag)
    analyser: String,

    # Chosen programming language
    language: String,

    # Mode of the analysis (link, pairs or full)
    mode: String): Boolean

    # Get a repository by name
    getRepo(

    # Git service of the repository
    git: String!,

    # Name of the repository
    name: String!):Repository

    # Create or update a repo by its name
    manageRepo(

    # Git service of the repository
    git: String!,

    # Full name of the repository
    fullName: String!,

    # The main programming language of the repository
    language: String,

    # Regexps for managed files
    filePatterns: [String],

    # Default analyser
    analyser: String,

    # Does the periodic analysis enabled
    periodicAnalysis: Boolean,

    # Delay of the periodic analysis in minutes
    periodicAnalysisDelay: Int,

    # Names of managed branches
    branches: [String],

    # Processing grade of analysis results
    analysisMode: String):Repository!

    getLocalBases(
    git: String!, repoName: String!, branch: String,
            fileName: String
    ):[BaseFileRecord]!

    getLocalSolutions(

    git: String!, repoName: String!, branch: String,
            student: String, fileName: String

    ):[SolutionFileRecord]!

    updateFilesOfRepo(

    # Git service of the repository
    git: String!,

    # Name of the repository
    name: String!):ComposedFiles!


}
